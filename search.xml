<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>虚拟主机</title>
      <link href="/posts/968.html"/>
      <url>/posts/968.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>虚拟主机 就是指此server块对外提供的虚拟主机，设置了主机的名称并配置好NDS，用户就可以使用这个名称向此虚拟主机发送请求了。<br><code>server_name name ...;</code><br>对于name而言，name可以只有一个名称，也可以由多个名称并列。之间用空格隔开。每个名字技术一个域名。由二段或者三段组成。之间由点号 . 隔开<br><code>server_name myserver.com www.myserver.com</code><br>nginx服务器规定，第一个名称作为此虚拟主机的主要名称。<br>在name中可以使用通配符 ‘<em>’，但通配符只能在由三段字符串组成的名称的手段或者尾端，或者由两断字符串组成的名称的尾段<br>```server_name *.myserver.com <a href="http://www.myserver" target="_blank" rel="noopener">www.myserver</a>.</em>;<code>在name中还可以使用正则表达式，并使用波浪号~ 作为正则表达式字符串的开始标记</code>server_name ~^www\d+.myserver.com<code>\d 代表0-9正则表达式捕捉功能</code>server_name ~^www.(.+).com$;```<br>当请求通过<a href="http://www.myserver.com到达NGINX服务器端时，将会被上面的正则表达式所匹配。其中" target="_blank" rel="noopener">www.myserver.com到达NGINX服务器端时，将会被上面的正则表达式所匹配。其中</a> myserver将会被捕捉，并记录到$1中，在本server块的下文配置中，当需要myserver时，就可以使用$1 代替myserver了。</p><p>也许服务器端包含很多虚拟主机，如果同时被多个虚拟主机匹配到如何处理呢<br>由于server_name 指令智齿使用通配符和正则表达式两种配置名称的方式<br>a    对于匹配方式不同的，按照以下的优先级选择虚拟主机，排在前面的优先处理请求<br>1    准确匹配    <code>server_name</code><br>2    通配符在开始时匹配server_name成功<br>3    通配符在结尾时匹配server_name成功<br>4    正则表达式匹配server_name 成功<br>b<br>在以上四种匹配方式中，如果server_name被处于统一由县级的匹配方式多次匹配成功。则首次匹配成功的虚拟主机处理请求。</p><p>基于IP的虚拟主机配置<br>linux操作系统支持IP别名的添加。配置急于IP的虚拟主机，即为nginx服务器提供的媚态虚拟主机配置一个不同的ip，因此需要将网卡设置为同事能够监听多个IP地址。<br><code>ifconfig eth1:0 192.168.1.31 netmask 255.255.255.0 up</code><br><code>ifconfig eth1:1 192.168.1.32 netmask 255.255.255.0 up</code><br>命令中up表示立即启动此别名</p><pre><code>http {    server    {        listen: 80;        server_name: 192.168.1.31}}</code></pre><p>配置location块<br>在nginx的官方文档中定义的location的语法结构为<br><code>location { = | ~ | ~* | ^~ } url...</code><br>其中url变量是带匹配的请求字符串，可以是不含正则表达式的字符串，可能是含有正则表达式的字符串，如 .\php$<br>=    用于标准url前，要求请求字符串与url严格匹配。如果已经匹配成功。就停止就绪向下搜索冰立即处理此请求。<br>~    用来表示url包含正则表达式，并且区分大小写<br><del>*    用于表示url包含正则表达式，并且不区分大小写。<br>如果url包含正则表达式，就必须要使用</del>或者~*标识</p><p>我们知道，在浏览器传送url时会对一部分字符进行url编码，比如空格被编码为%20, 问号被编码为 %3f等，^<del>有一个特点是，他对url中的这些符号将会进行编码处理。比如 如果location块收到url为/html/%20/data    ,则当nginx服务器搜索到配置为 ^</del>/html/ /data 的location时，可以匹配成功</p><p>配置请求的根目录<br>web服务器接收到网络请求之后，首先要在服务器端指定目录中寻找请求资源，在nginx服务器中，指令root就是用来配置这个根目录的<br><code>root path;</code><br>path为nginx服务器接收到请求以后查找资源的根目录路径。path变量中可以包含nginx服务器预设的大多数变量，只有$document_root and $realpath_root不可使用<br>此指令可以在http块，server块或者location块使用</p><pre><code>location /data/{    root     /locationtest1;}curl /locationtest1/data/*.html     类似</code></pre><p>更改location的URL<br>在location还可以使用alias指令改变location接收到的url请求路径<br>alias    path；<br>其中path即为修改后的根路径，</p><pre><code>location    ~^/data/(.+\.(htm|html))$ {alias    /locationtest1/other/$1;}</code></pre><p>设置网站的默认首页<br>指令index用于设置网站的默认首页，他一般可以有两个作用，一是用户在发出请求访问网站时，请求地址可以不写首页名称。二是 可以对一个请求，根据其请求内容而设置不同的首页。<br><code>index file.....;</code><br>其中 file变量可以包括多个文件名，其间使用空格分隔，也可以包含其他变量。</p><pre><code>location    ~^/data/(.+)/web/    ${    index index.$1.html    index.my1.html    index.html;    }</code></pre><p>当location块接收到/data/locationtest/web/时，匹配成功，它首先将预置变量$1置为locationtest,然后localtion块接收到/data/index.htm的请求时，匹配成功。之后根据alias指令的设置将匹配到的/location/ data 更改为locationtest1/other/了.</p><p>查看网络的错误页面<br>如果用户端尝试查看网页时遇到问题，服务器会将http错误从网站发送到web浏览器，如果无法显示网页，web浏览器会显示网站发送的实际错误网页或web浏览器内置的友好错误信息。nginx服务器智齿自定义错误网页的显示内容。可以通过这一功能在网站发生错误时为用户提供人性化的错误显示页面。</p><p>HTTP消息        代码                    含义<br>已移动            <code>HTTP301</code>            请求的数据具有新的位置，并且更改是永久的。<br>已找到            <code>HTTP302</code>        请求的数据临时具有不同URL<br>请参阅其他        <code>HTTP303</code>            可在另一URL下找到对请求的响应。并且应使用get方法检索此响应。<br>未修改            <code>HTTP304</code>        未按预期修改文档<br>使用代理        <code>HTTP305</code>        必须通过位置字段中提供的代理来访问请求的资源<br>未使用            <code>HTTP306</code>    不再使用，但保留此代码以便将来使用<br>无法找到网页    <code>HTTP400</code>        可以连接到web服务器，但是由于web地址URL的问题，无法找到网页<br>网站拒绝显示此网页 <code>HTTP403</code>        可以连接到网站，但internet explorer没有显示网页的权限<br>无法找到网页    <code>HTTP404</code>    可以连接到网站，但找不到网页。导致此错误的原因有可能是该网页暂时不可用或网页已被删除<br>网站无法显示该页面    <code>HTTP405</code>        可以连接到网站，但网页内容无法下载到用户计算机。这通常是由网页编写方式问题引起的<br>无法读取此网页格式    <code>HTTP406</code>        能够从网站接受信息，但internet explorer不能识别其格式，因而无法正确地显示消息。<br>该网站太忙，无法显示此网页    <code>HTTP408或409</code>    服务器显示该网页的时间太长，或对同一网页的请求太多<br>网页不复存在    <code>HTTP410</code>            可以连接到网站，但无法找到网页，与HTTP错误404不同，此错误是永久性的，而且由网站管理员打开。<br>网站无法显示该页面    <code>HTTP500</code>    正在访问的网站出现服务器问题，<br>该问题组织了此网页的显示。常见的原因是网站正在维护或使用脚本的交互式网站上的程序出错<br>未执行            <code>HTTP501</code>        没有将正在访问的网站设置为显示浏览器所请求的内容<br>不支持的版本    HTTP505            改网站不支持浏览器用于请求网页HTTO协议 最常见的HTTP/1.1</p><p>nginx设置网站错误页面的指令为error_page<br><code>error_page        code .... [=[response]]url</code><br><code>code</code>    要处理的HTTP错误代码，<br><code>response</code>        可选项，将code指定的错误代码转化为新的错误代码<br><code>url</code>        错误页面的路径或者网站地址，如果设置为路径，则是以nginx服务器安装路径下htmk目录为根路径的相对路径，如果设置为网址，nginx服务器会直接访问该网址获取错误页面</p><pre><code>error_page    404    /404.htmlerror_page    403        http://somewebsite.com/forbidden.html;error_page    410 =301    /empty.gif</code></pre><p>设置将410消息，使用nginx安装路径/html/empty.gif    返回给用户端301的消息（已移动）</p><p>基于IP配置nginx的访问权限<br>nginx配置通过两种途径智齿基本访问权限的控制，其中一种是由HTTP标准ngx_http_access_module支持的，其通过IP来判断客户端是否拥有对NGINX的访问权限，<br>allow指令，用于设置允许访问nginx的客户端IP<br><code>allow     address    |CIDR    all;</code><br>address    允许方额嗯的客户端IP地址，不支持同时设置多个。如果有多个IP需要设置，需要重复使用allow指令。<br>CIDR    允许访问的客户端的CIDR地址，例如202.80.18.23/25，千面是32位ip地址。后面/25    代表改IP地址中钱25位是网络部分，<br>all        代表所有客户端访问。支持IPV6地址<br><code>allow    2620:100:e000:8001;</code><br>另一个指令是deny，作用刚好和allow指令相反，他用于设置禁止访问nginx的客户端IP。<br><code>deny    address|CIDR|ALL;</code></p><p>这两个指令可以在http块 server块或者location块中配置，在使用这两个指令时，要注意设置all的用法</p><pre><code>location / {    deny    192.168.1.1;    allow    192.168.1.0/24;    deny    all;}</code></pre><p>基于密码配置nginx的访问权限<br>nginx支持局域httobasic authentication协议的认证。该协议是一种http性质的认证办法，需要识别用户名和密码，认证失败的哭护短不具有访问nginx服务器的权限。该功能由HTTO标准模块ngx_http_basic_module支持，这是有两个指令需要学习<br>auth_basic指令，用于开启或者关闭该认证功能<br><code>auth_basic string |off;</code><br>string，开启该认证功能<br>off        关闭该认证功能<br><code>auth_basic_user_file file;</code><br>其中    file为密码文件的绝对路径<br>这里的密码文件支持铭文或者密码加密后的文件。</p><pre><code>name1:password1name2:password2:commentname3:password3</code></pre><p>加密密码可以使用crypt()函数进行密码加密的格式，在linux平台上可以使用htpasswd命令生成。在php和perl等语言中，也可以提供crypt()函数<br><code>htpasswd -c -d /nginx/conf/pass_file username;</code><br>例 </p><pre><code>    auth_basic_user_file /etc/nginx/nginx_userfile;    auth_basic string;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟主机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置文件</title>
      <link href="/posts/27743.html"/>
      <url>/posts/27743.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nginx配置文件<br>#这里是全局块，可以配置一些全局生效的配置，比如nginx启动用户，<code>nginx的worke_press</code></p><pre><code>events {#event块，配置worker_connections，也是全局生效}http {#http块，nginx服务器配置中的重要部分，代理，缓存，日志定义等绝大部分功能以及第三方配置都可以放在这个模块中。server {#server块和虚拟主机有密切关系，（不明白虚拟主机的概念请自行谷歌），每一个http块可以包含多个server块，在server块中配置虚拟主机需要监听的端口，IP或域名location {#每一个server块中可以包含多个location块，从严格意义上讲，location块只是server块的一个指令，它会接收到域名后面跟着的字符串，根据字符串来进行匹配，对特定请求进行处理，重定向，缓存，以及应答控制等功能。}}}</code></pre><pre class=" language-shell"><code class="language-shell">user  nginx nginx;            worker_processes  1;        #error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server {        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html;            index  index.html index.htm;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ {        #    proxy_pass   http://127.0.0.1;        #}        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        location ~ \.php$ {            root           html;            fastcgi_pass   127.0.0.1:9000;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  /home/nginx-server/html$fastcgi_script_name;            include        fastcgi_params;        }        # deny access to .htaccess files, if Apache's document root        # concurs with nginx's one        #        #location ~ /\.ht {        #    deny  all;        #}    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}</code></pre><p><code>user  nginx nginx;</code>        ##用于配置运行nginx服务器用户（组）的指令<br><code>user     nobody    nobody;</code>     user指令只能在全局快使用<br>worker_processes  1;        ##是nginx服务器实现并发处理服务的关键所在收到软件本身，操作系统本身资源的限制<br><code>worker_processes  auto|number;</code><br>使用后查看</p><pre><code>ps -aux|grep nginxroot      2091  0.0  0.0 112712   960 pts/0    S+   10:45   0:00 grep --color=auto nginxroot      2327  0.0  0.0  46364  2092 ?        Ss   May15   0:00 nginx: master process /home/nginx-server/sbin/nginxnginx    31279  0.0  0.0  46776  2576 ?        S    10:21   0:00 nginx: worker process</code></pre><p>配置nginx存放进程pid路径<br>nginx进程作为系统的守护进程运行，我们需要在某文件中保存当前运行程序的主进程号<br><code>pid filename;</code><br>配置错误日志的存放路径<br>在全局快、http块、和server块中对可以对nginx服务器的日志进行相关配置。这里首先介绍全局块下日志的存放配置，后两种情况的配置基本相同，只是作用域不同。    使用的指令是error_log</p><pre><code>error_log file|stderr|[debug|info|notice|warn|error|crit|alert|emerg];</code></pre><p>从语法结构看nginx服务器的日志智齿输出到某一固定的文件file或者输出到标准错误输出stderr;日志分级别是可选项，由低到高debug（需要在变异的时候使用 –with-debug 开启debug开关），设置某一级别后，比这以及别搞得日志也会被记录。比如设置warn级别后，级别为warn以及error、crit|alert|emerg 都会被记录下来<br>templase<br>error_log logs/error.log error;</p><p>配置文件的导入<br>include file;<br>include conf.d/*.conf</p><p>设置网络连接的序列化<br>nginx配置中包含了这样一条指令 accept_mutex,当其设置为开启的时候，将会对多个nginx进程接收连接进行序列化，防止多个进程对连接的争抢。<br>accept_mutex on |off;<br>其指令默认开启，只能在events块中进行配置</p><p>设置是否允许同时接收多个网络连接<br>multi_accept on|off;<br>每个nginx服务器的worker process都有能力同时接收多个新到达的网络连接，但是这需要在配置文件中进行设置，其指令为multi_accept<br>此指令默认为关闭状态，即每一个worker process一次只能接收一个新到达的网络连接， 此指令只能在events块中进行生效。</p><p>事件驱动选择<br>nginx服务器提供了多重是按驱动模型来处理网络信息。配置文件中为我们提供了相关的指令来强制nginx服务器选择哪种时间驱动模型进行消息处理，指令为use,语法结构为<br><code>use method;</code><br>其中method可选择的内容有： select 、poll 、kqueue 、 epoll 、 rtsig 、 /dev/null以及eventport<br>可以在编译时使用 –with-select_module和–without-select_module设置强制编译 select模块到nginx内核。使用 –with-poll_module和–wothout-poll_module设置是否强制编译poll模块到nginx内核。<br>此指令只能在events块中进行配置。</p><p>配置最大连接数<br>指令<code>worker_connections</code>主要用来设置允许每一个 worker process同事开启的最大连接数。其语法结构为<br><code>worker_connections number;</code><br>此指令的默认设置为512.<br>这里的number数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外 number值不能大于操作系统支持打开的最大文件句柄数量。</p><p>定义MIME=type<br>我们知道在常用的浏览器中，可以显示的内容有HTML.XML.GIF及Flash等种类繁多的文本、媒体库等资源，浏览器为了区分这些资源，需要使用MIME Type.换言之，MIME Type是网络资源的媒体类型。nginx服务器作为web服务器，必须能够识别前端请求的资源类型<br>在默认nginx配置文件中，我们按到在http全局块中有一下两行配置：<br>    <code>include mime.types;</code><br><code>default_type application/octet-stream;</code><br>第一行从外部引用了mime_types文件，我们来看一下他的内容分段</p><pre><code>types {    text/html                                        html htm shtml;    text/css                                         css;    text/xml                                         xml;    image/gif                                        gif;    image/jpeg                                       jpeg jpg;    application/javascript                           js;    application/atom+xml                             atom;    application/rss+xml                              rss;    text/mathml                                      mml;    text/plain                                       txt;    text/vnd.sun.j2me.app-descriptor                 jad;    text/vnd.wap.wml                                 wml;    text/x-component                                 htc;    image/png                                        png;    image/svg+xml                                    svg svgz;    image/tiff                                       tif tiff;    image/vnd.wap.wbmp                               wbmp;    image/webp                                       webp;    image/x-icon                                     ico;    image/x-jng                                      jng;    image/x-ms-bmp                                   bmp;    font/woff                                        woff;    font/woff2                                       woff2;</code></pre><p>从mime_types文件的内容分段可以看到，其中定义了一个types结构，结构中包含了浏览器能够识别MIME类型以及对应于相关类型的文件后缀名。由于mime_types是主配置文件应用的第三方文件，一次，types也是nginx配置文件中的一个配置块，我们也可以称之为types块，其用于定义MIME类型<br>第二行中使用指令default_type配置了用于处理前端请求的MIME类型，其语法结构为<br>default_type mime-type;<br>如果不加指令默认为text/plain 此指令还可以在http块  server块或者location块进行配置。</p><p>自定义服务目标日志</p><p>nginx服务器智齿对服务日志的格式、大小、输出等进行配置，需要使用两个指令，分别为access_log和logformat指令<br>access_log指令语法为<br>access_log path[format[buffer=size]]<br>path    配置服务日志的文件存放的路径和名称<br>format    可选项自定义服务日志的格式字符串，也可以通过 格式串的名称 使用log_format指令定义好的格式<br>size  配置临时存放日志的内存缓冲区大小</p><p>此指令可以在http块 、server块或者location块进行配置。<br>access_log logs/access.log combined;  combined 默认定义的日志格式字符串的名称</p><pre><code>access_log     off;</code></pre><pre class=" language-conf"><code class="language-conf">log_format name string ,,,;teamplasehttp {    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';</code></pre><p>配置允许sendfile方式传输文件<br>sendfile和sendfile_max_chunk以及他们的语法<br><code>sendfile    on|off;</code><br>用于开启或者关闭使用sendfile()传输文件，默认值为off。可以在http块、server块或者location块中进行配置<br><code>sendfile_max_chunk size;</code><br>其中，size值如果大于0，nginx进程的每个worker process每次调用sendfile()传输的数据量最大不能超过这个值，如果设置为0，则无限制。此指令可以在http块 server块或者location块中进行配置</p><p>配置连接超时时间<br>用户建立会话连接后，nginx服务器可以保持这些连接打开一段时间，指令keepalive_timeout就是用来设置此时间的，其语法结构<br><code>keepalive_timeout timeout[header_timeout];</code><br>timeout    服务器端对连接的保持时间。默认值为75s<br>header_timeout可选项，在应对报文头部的keep-alive域设置超时时间： keep-alive<br><code>timeout=header_timeout</code>报文中的这个指令可以被Mozilla或者Konqueror识别<br>此指令可以在server块和location块配置<br><code>keepalive_timeout 120s 100s;</code><br>其含义是，在服务端保持连接的时间设置为120s,发给用户端的应答报文头部总kepp-alive域的超时时间设置为100S<br>此指令可以在http块 server块或者location块中进行配置</p><p>单连接请求数上限<br>nginx服务器端和用户端建立会话连接后，用户端通过此链接发送请求，指令keepalive——requests用于限制用户通过某一连接向nginx服务器发送请求的次数<br><code>keepalive_requests number;</code><br>此指令还可以出现在server块和location块中，默认设置为100</p><p>配置网络监听<br>配置监听使用指令listen,其配置方法主要有三种，我们先分别介绍三种配置的语法结构，然后统一介绍设计的相关变量和标识符<br>第一种配置监听IP地址</p><pre><code>listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl];</code></pre><p>第二种配置监听端口，其语法结构</p><pre><code>listen port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size][accept_filter=filter] [bind] [ipv6only=on|off] [ssl]; </code></pre><p>第三种配置unix Domain Socket    一种在原有Socket框架上发展起来的IPC机制，用于在单个主机上执行客户/服务器通信。</p><pre><code>listen unix:path [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred]</code></pre><p>address IP地址，如果是IPv6地址 需要使用中括号[]括起来，比如[fe80::1]等<br>port    端口号    如果定义了IP地址没有定义端口号，就是用80端口<br>path socket文件路径，如/var/run/nginx.sock等<br>default_server    标识符    将此虚拟机主机设置为address:port 的默认主机</p><p>注意<br>setflb=number,    nginx中使用这个变量为监听socket关联路由表，目前只对FreeBSD起作用 不常用<br>backlog=number,    设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在FreeBSD中默认为-1，其他平台默认为511.<br>revbuf=size,    设置监听socket接收缓存区大小<br>sndbuf=size,    设置监听socket发送缓存区大小<br>deferred,标识符,    将accept()设置为Deferred模式。<br>accept_filter=filter    设置监听端口对请求的过滤，被过滤的内容不能被接收和处理。<br>bind,标识符        使用独立的bind()处理次address:port 一般情况下，对于端口相同二IP地址不同的多个连接，nginx服务器将只是用一个监听命令，并使用bind()处理端口相同的所有连接。<br>ssl ,标识符 设置会话连接使用SSL模式进行，茨表示服和nginx服务器提供的https服务有关，</p><p><code>listen *:80|*:8000;</code><br><code>listen 192.168.1.1:8000;</code><br><code>listen 8000;</code></p><p><code>listen 192.168.1.10 default_server backlog=1024;</code></p><p>设置192.168.1.10的链接请求默认由此虚拟主机处理<br>并且允许最多1024网络连接同事处于挂起状态。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx模块化</title>
      <link href="/posts/18763.html"/>
      <url>/posts/18763.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nginx模块化<br>nginx模块分为核心模块、标准模块、标准HTTP模块、可选HTTP模块、邮件服务模块以及第三方模块等五大类<br>核心模块市值nginx服务器正常运行必不可少的模块，他们提供了nginx最基本最核心的服务，如进程管理、权限控制、错误日志记录等。标准HTTP模块主要用于快速编译nginx后包含的模块。可选HTTP模块主要用于扩展标准的HTTP模块，使其能够处理一些特殊的HTTP请求,邮件服务模块主要用于支持nginx的邮件服务，第三方模块是为了扩展nginx服务器应用，完成特殊功能而由第三方机构或者个人编写的可编译到nginx中的模块，</p><pre><code>[root@zabbix objs]# ls /usr/local/src/nginx-1.16.1/objs/autoconf.err  Makefile  nginx  nginx.8  ngx_auto_config.h  ngx_auto_headers.h  ngx_modules.c  ngx_modules.o  src</code></pre><pre><code>[root@zabbix objs]# cat ngx_modules.c|grep extern#extern ngx_module_t  ngx_core_module;#extern ngx_module_t  ngx_errlog_module;#extern ngx_module_t  ngx_conf_module;extern ngx_module_t  ngx_openssl_module;#extern ngx_module_t  ngx_regex_module;#extern ngx_module_t  ngx_events_module;#extern ngx_module_t  ngx_event_core_module;#extern ngx_module_t  ngx_epoll_module;extern ngx_module_t  ngx_thread_pool_module;extern ngx_module_t  ngx_http_module;extern ngx_module_t  ngx_http_core_module;extern ngx_module_t  ngx_http_log_module;extern ngx_module_t  ngx_http_upstream_module;extern ngx_module_t  ngx_http_v2_module;extern ngx_module_t  ngx_http_static_module;extern ngx_module_t  ngx_http_dav_module;extern ngx_module_t  ngx_http_autoindex_module;extern ngx_module_t  ngx_http_index_module;extern ngx_module_t  ngx_http_mirror_module;extern ngx_module_t  ngx_http_try_files_module;extern ngx_module_t  ngx_http_auth_basic_module;extern ngx_module_t  ngx_http_access_module;extern ngx_module_t  ngx_http_limit_conn_module;extern ngx_module_t  ngx_http_limit_req_module;extern ngx_module_t  ngx_http_realip_module;extern ngx_module_t  ngx_http_geo_module;extern ngx_module_t  ngx_http_map_module;extern ngx_module_t  ngx_http_split_clients_module;extern ngx_module_t  ngx_http_referer_module;extern ngx_module_t  ngx_http_rewrite_module;extern ngx_module_t  ngx_http_ssl_module;extern ngx_module_t  ngx_http_proxy_module;extern ngx_module_t  ngx_http_fastcgi_module;extern ngx_module_t  ngx_http_uwsgi_module;extern ngx_module_t  ngx_http_scgi_module;extern ngx_module_t  ngx_http_grpc_module;extern ngx_module_t  ngx_http_memcached_module;extern ngx_module_t  ngx_http_empty_gif_module;extern ngx_module_t  ngx_http_browser_module;extern ngx_module_t  ngx_http_flv_module;extern ngx_module_t  ngx_http_mp4_module;extern ngx_module_t  ngx_http_upstream_hash_module;extern ngx_module_t  ngx_http_upstream_ip_hash_module;extern ngx_module_t  ngx_http_upstream_least_conn_module;extern ngx_module_t  ngx_http_upstream_random_module;extern ngx_module_t  ngx_http_upstream_keepalive_module;extern ngx_module_t  ngx_http_upstream_zone_module;extern ngx_module_t  ngx_http_stub_status_module;extern ngx_module_t  ngx_http_write_filter_module;extern ngx_module_t  ngx_http_header_filter_module;extern ngx_module_t  ngx_http_chunked_filter_module;extern ngx_module_t  ngx_http_v2_filter_module;extern ngx_module_t  ngx_http_range_header_filter_module;extern ngx_module_t  ngx_http_gzip_filter_module;extern ngx_module_t  ngx_http_postpone_filter_module;extern ngx_module_t  ngx_http_ssi_filter_module;extern ngx_module_t  ngx_http_charset_filter_module;extern ngx_module_t  ngx_http_sub_filter_module;extern ngx_module_t  ngx_http_addition_filter_module;extern ngx_module_t  ngx_http_userid_filter_module;extern ngx_module_t  ngx_http_headers_filter_module;extern ngx_module_t  ngx_http_copy_filter_module;extern ngx_module_t  ngx_http_range_body_filter_module;extern ngx_module_t  ngx_http_not_modified_filter_module;</code></pre><p>由于使用<code>extern</code>关键词修饰，因此各模块均可以被其他模块访问<br>这里简要说明一下nginx中模块的明敏习惯。一般以ngx_作为前缀，_module作为后缀,中间使用一个或者多个英文单词描述模块的功能，不如ngx_core_module，中间的<code>core</code>表示该模块提供了nginx程序的核心功能。<br>蓑鲉的固有模块的源码放在编译目录下的src目录中，在src目录中，我们看到一共分成了<code>core、event、http、mail、和os</code>等6个目录。从这里看到，源码中包含了邮件服务的模块，但在快速编译默认不将其编译到nginx中</p><p>1.核心模块<br>详细来说 nginx的核心模块主要包含对两类功能的支持，一类是主体功能，包括进程管理、权限控制、错误日志、解析日志等，另一类适用于响应请求时间必需的功能，包括事件驱动机制、正则表达式解析等</p><p>nginx服务器的web请求处理机制<br>从设计构架上来说 nginx服务器是与众不同的，不同之处一方面体现在它的模块化设计，另一方体现在他对客户端请求的处理机制上<br>完成并行处理请求工作有三种方式可供选择：    多进程方式、多线程方式、异步方式</p><p>多进程方式、多线程方式、异步方式多进程方式市值，服务器每当接收到一个客户端是，就有服务器朱进车女生成一个子进程出来和客户端建立连接进行交互，知道连接断开，该子进程就结束了。</p><p>异步方式分为四种<br>同步阻塞     同步非阻塞    异步阻塞    异步非阻塞<br>同步阻塞<br>发送方向接收方发送请求后，一直等待响应。接收方处理请求时进行的IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，其间不能进行其他龚总，比如 在超市排队付账时，发送方和接收方收款员付款后需要等待收款员找零，其间不能做其他的事情，而收款员要等待收款机返回结果IO操作 响应期间也只能等待，不能做其他事情，这种方法实现简单，但是效率不高</p><p>同步非阻塞<br>发送方向接收方发送其你去后，一直等待响应，接收方处理请求时进行的操作如果不能马上得到结果，就立即返回，去做其他的事情，但是由于没有得到请求处理结果，不影响发送发，发送方一直等待。一直到IO操作完成后，接收方获得结果响应发送方后，接收方才佳能进入下一次请求过程。在实际中不使用这种方式。</p><p>异步阻塞<br>发送方向接收方发送请求后，不用等待响应，可以接着进行其他工作，，接收方处理请求时进行的IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，其间不能进行其他工作    在实际中不使用这种方式。<br>异步非阻塞方式<br>发送方向接收方发送请求后，不用等待响应。可继续其他工作。接收方处理请求时记性io操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。当io操作完成以后，将完成状态和结果通知接收方，接收方在响应发送方。这种方法最实用</p><p>nginx服务器如何处理请求<br>进程模型有两种 single模式和master—worker模式</p><p>nginx服务器的事件处理机制<br>IO如何调用把自己的状态通知给工作进程<br>一半解决这个问题的方案有两种，一是让工作进程在进行其他工作的过程中将隔一段时间就去检查一下IO的运行状态，如果完成，就去响应客户端，如果未完成 就继续正在进行的工作，而是Io调用在完成后能中东通知工作进程。对于欠着，虽然工作进程在IO调用过程中没有等待，但不断的检查仍然在时间和资源商导致了不小的开销，最理想的是第二种<br>具体来说 select/poll/epoll/kqueue等这样的系统调用就是用来支持第二种解决方案的。这些系统调用，也被常称为事件驱动模型，他们提出糊了一种机制，让进程可以同时处理多个并发请求，不用关心IO调用的具体状态。IO调用完全由时间驱动模型来管理</p><p>nginx服务器的事件驱动模型<br>事件驱动模型一般是由事件收集器、时间发送器和事件处理器三部分基本单元组成</p><p>nginx服务器的进程<br>一类是主进程 一类是是由主进程生成的工作进程， 为缓存索引建立索引的进程</p><p>主进程 master process<br>主要功能是与外界通信和对内部其他进程进行管理<br>读取nginx配置文件并验证其有效性和正确性<br>建立、绑定和关闭Socket<br>按照外界指令，比如重启、升级及退出服务器等指令<br>不中断服务，实现平滑重启 应用新配置<br>不中断服务，实现平滑升级，升级失败进行回滚处理<br>开启日志文件，获取文件的描述符<br>编译和处理perl脚本。</p><p>工作进程<br>正常情况下生存与主进程的整个生命周期<br>接收客户端请求<br>IO调用，获取响应数据<br>与后端服务器通信，接收后端服务器处理结果<br>发送请求结果，响应客户端请求<br>接收主程序指令，比如重启、升级和退出等指令</p><p>缓存索引重建及管理进程<br>cache模块，主要由缓存索引重建cache loader和缓存索引管理 cache manager两类进程完成工作<br>缓存索引重建进程是在nginx服务器启动一段时间之后默认是1分钟由主进程生成，在缓存元数据重建完成后就自动退出；缓存索引管理进程一般存在于主进程的整个生命周期，负责对缓存索引进行管理</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx优化</title>
      <link href="/posts/31321.html"/>
      <url>/posts/31321.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>nginx配置文件<br>#这里是全局块，可以配置一些全局生效的配置，比如nginx启动用户，nginx的worke_press</p><pre class=" language-shell"><code class="language-shell">events {#event块，配置worker_connections，也是全局生效}http {#http块，nginx服务器配置中的重要部分，代理，缓存，日志定义等绝大部分功能以及第三方配置都可以放在这个模块中。server {#server块和虚拟主机有密切关系，（不明白虚拟主机的概念请自行谷歌），每一个http块可以包含多个server块，在server块中配置虚拟主机需要监听的端口，IP或域名location {#每一个server块中可以包含多个location块，从严格意义上讲，location块只是server块的一个指令，它会接收到域名后面跟着的字符串，根据字符串来进行匹配，对特定请求进行处理，重定向，缓存，以及应答控制等功能。}}}}</code></pre><pre class=" language-shell"><code class="language-shell">user  nginx nginx;            worker_processes  1;        #error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '    #                  '$status $body_bytes_sent "$http_referer" '    #                  '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server {        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html;            index  index.html index.htm;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ {        #    proxy_pass   http://127.0.0.1;        #}        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        location ~ \.php$ {            root           html;            fastcgi_pass   127.0.0.1:9000;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  /home/nginx-server/html$fastcgi_script_name;            include        fastcgi_params;        }        # deny access to .htaccess files, if Apache's document root        # concurs with nginx's one        #        #location ~ /\.ht {        #    deny  all;        #}    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}</code></pre><p>user  nginx nginx;            ##用于配置运行nginx服务器用户（组）的指令<br><code>user     nobody    nobody;</code>      user指令只能在全局快使用<br><code>worker_processes  1;</code>    ##是nginx服务器实现并发处理服务的关键所在收到软件本身，操作系统本身资源的限制<br><code>worker_processes  auto|number;</code><br>使用后查看<code>ps -aux|grep nginx</code></p><pre><code>root      2091  0.0  0.0 112712   960 pts/0    S+   10:45   0:00 grep --color=auto nginxroot      2327  0.0  0.0  46364  2092 ?        Ss   May15   0:00 nginx: master process /home/nginx-server/sbin/nginxnginx    31279  0.0  0.0  46776  2576 ?        S    10:21   0:00 nginx: worker process</code></pre><p>配置nginx存放进程pid路径<br>nginx进程作为系统的守护进程运行，我们需要在某文件中保存当前运行程序的主进程号<br><code>pid filename;</code><br>配置错误日志的存放路径<br>在全局快、http块、和server块中对可以对nginx服务器的日志进行相关配置。这里首先介绍全局块下日志的存放配置，后两种情况的配置基本相同，只是作用域不同。    使用的指令是error_log<br><code>error_log file|stderr|[debug|info|notice|warn|error|crit|alert|emerg];</code><br>从语法结构看nginx服务器的日志智齿输出到某一固定的文件file或者输出到标准错误输出stderr;日志分级别是可选项，由低到高debug（需要在编译的时候使用 <code>--with-debug</code> 开启debug开关），设置某一级别后，比这以及别搞得日志也会被记录。比如设置warn级别后，级别为warn以及error、crit|alert|emerg 都会被记录下来<br>templase<br><code>error_log logs/error.log error;</code></p><p>配置文件的导入<br><code>include file;</code><br><code>include conf.d/*.conf</code></p><p>设置网络连接的序列化<br>nginx配置中包含了这样一条指令 accept_mutex,当其设置为开启的时候，将会对多个nginx进程接收连接进行序列化，防止多个进程对连接的争抢。<br><code>accept_mutex on |off;</code><br>其指令默认开启，只能在events块中进行配置</p><p>设置是否允许同时接收多个网络连接<br><code>multi_accept on|off;</code><br>每个nginx服务器的worker process都有能力同时接收多个新到达的网络连接，但是这需要在配置文件中进行设置，其指令为multi_accept<br>此指令默认为关闭状态，即每一个worker process一次只能接收一个新到达的网络连接， 此指令只能在events块中进行生效。</p><p>事件驱动选择<br>nginx服务器提供了多重是按驱动模型来处理网络信息。配置文件中为我们提供了相关的指令来强制nginx服务器选择哪种时间驱动模型进行消息处理，指令为use,语法结构为<br><code>use method;</code><br>其中method可选择的内容有：<code>select 、poll 、kqueue 、 epoll 、 rtsig 、 /dev/null</code>以及<code>eventport</code><br>可以在编译时使用 <code>--with-select_module</code>和<code>--without-select_module</code>设置强制编译 select模块到nginx内核。使用 <code>--with-poll_module</code>和<code>--wothout-poll_module</code>设置是否强制编译poll模块到nginx内核。<br>此指令只能在events块中进行配置。</p><p>配置最大连接数<br>指令<code>worker_connections</code> 主要用来设置允许每一个 worker process同事开启的最大连接数。其语法结构为<br><code>worker_connections number;</code><br>此指令的默认设置为512.<br>这里的number数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外 number值不能大于操作系统支持打开的最大文件句柄数量。</p><p>定义MIME=type<br>我们知道在常用的浏览器中，可以显示的内容有HTML.XML.GIF及Flash等种类繁多的文本、媒体库等资源，浏览器为了区分这些资源，需要使用MIME Type.换言之，MIME Type是网络资源的媒体类型。nginx服务器作为web服务器，必须能够识别前端请求的资源类型<br>在默认nginx配置文件中，我们按到在http全局块中有一下两行配置：<br>    <code>include mime.types;    default_type application/octet-stream;</code><br>第一行从外部引用了mime_types文件，我们来看一下他的内容分段</p><pre class=" language-shell"><code class="language-shell">types {    text/html                                        html htm shtml;    text/css                                         css;    text/xml                                         xml;    image/gif                                        gif;    image/jpeg                                       jpeg jpg;    application/javascript                           js;    application/atom+xml                             atom;    application/rss+xml                              rss;    text/mathml                                      mml;    text/plain                                       txt;    text/vnd.sun.j2me.app-descriptor                 jad;    text/vnd.wap.wml                                 wml;    text/x-component                                 htc;    image/png                                        png;    image/svg+xml                                    svg svgz;    image/tiff                                       tif tiff;    image/vnd.wap.wbmp                               wbmp;    image/webp                                       webp;    image/x-icon                                     ico;    image/x-jng                                      jng;    image/x-ms-bmp                                   bmp;    font/woff                                        woff;    font/woff2                                       woff2;</code></pre><p>从mime_types文件的内容分段可以看到，其中定义了一个types结构，结构中包含了浏览器能够识别MIME类型以及对应于相关类型的文件后缀名。由于mime_types是主配置文件应用的第三方文件，一次，types也是nginx配置文件中的一个配置块，我们也可以称之为types块，其用于定义MIME类型<br>第二行中使用指令default_type配置了用于处理前端请求的MIME类型，其语法结构为<br><code>default_type mime-type;</code><br>如果不加指令默认为text/plain 此指令还可以在http块  server块或者location块进行配置。</p><p>自定义服务目标日志</p><p>nginx服务器智齿对服务日志的格式、大小、输出等进行配置，需要使用两个指令，分别为access_log和logformat指令<br>access_log指令语法为<br><code>access_log path[format[buffer=size]]</code><br>path    配置服务日志的文件存放的路径和名称<br>format    可选项自定义服务日志的格式字符串，也可以通过 格式串的名称 使用log_format指令定义好的格式<br>size  配置临时存放日志的内存缓冲区大小</p><p>此指令可以在http块 、server块或者location块进行配置。<br><code>access_log logs/access.log combined;</code>  combined 默认定义的日志格式字符串的名称<br><code>access_log     off;</code></p><p>log_format 参数可以查看上篇文章nginx内置变量<br><code>log_format name string ,,,;</code><br>teamplase</p><pre class=" language-shell"><code class="language-shell">http {    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';</code></pre><p>配置允许sendfile方式传输文件<br>sendfile和sendfile_max_chunk以及他们的语法<br><code>sendfile    on|off;</code><br>用于开启或者关闭使用sendfile()传输文件，默认值为off。可以在http块、server块或者location块中进行配置<br><code>sendfile_max_chunk size;</code><br>其中，size值如果大于0，nginx进程的每个worker process每次调用sendfile()传输的数据量最大不能超过这个值，如果设置为0，则无限制。此指令可以在http块 server块或者location块中进行配置</p><p>配置连接超时时间<br>用户建立会话连接后，nginx服务器可以保持这些连接打开一段时间，指令keepalive_timeout就是用来设置此时间的，其语法结构<br><code>keepalive_timeout timeout[header_timeout];</code><br>timeout    服务器端对连接的保持时间。默认值为75s<br>header_timeout可选项，在应对报文头部的keep-alive域设置超时时间： keep-alive<br><code>timeout=header_timeout</code>    报文中的这个指令可以被Mozilla或者Konqueror识别<br>此指令可以在server块和location块配置<br><code>keepalive_timeout 120s 100s;</code><br>其含义是，在服务端保持连接的时间设置为120s,发给用户端的应答报文头部总kepp-alive域的超时时间设置为100S<br>此指令可以在http块 server块或者location块中进行配置</p><p>单连接请求数上限<br>nginx服务器端和用户端建立会话连接后，用户端通过此链接发送请求，指令keepalive——requests用于限制用户通过某一连接向nginx服务器发送请求的次数<br><code>keepalive_requests number;</code><br>此指令还可以出现在server块和location块中，默认设置为100</p><p>配置网络监听<br>配置监听使用指令listen,其配置方法主要有三种，我们先分别介绍三种配置的语法结构，然后统一介绍设计的相关变量和标识符<br>第一种配置监听IP地址<br><code>listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl];</code><br>第二种配置监听端口，其语法结构</p><pre><code>listen port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size][accept_filter=filter] [bind] [ipv6only=on|off] [ssl];</code></pre><p>第三种配置unix Domain Socket    一种在原有Socket框架上发展起来的IPC机制，用于在单个主机上执行客户/服务器通信。</p><pre><code>listen unix:path [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred]</code></pre><p><code>address</code>IP地址，如果是IPv6地址 需要使用中括号[]括起来，比如[fe80::1]等<br>``port    <code>端口号    如果定义了IP地址没有定义端口号，就是用80端口</code>path socket<code>文件路径，如/var/run/nginx.sock等</code>default_server<code>标识符    将此虚拟机主机设置为</code>address:port``` 的默认主机</p><p>注意<br><code>setflb=number,</code>    nginx中使用这个变量为监听socket关联路由表，目前只对FreeBSD起作用 不常用<br><code>backlog=number,</code>    设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在FreeBSD中默认为-1，其他平台默认为511.<br><code>revbuf=size,</code>设置监听socket接收缓存区大小<br><code>sndbuf=size,</code>设置监听socket发送缓存区大小<br><code>deferred,</code>标识符,    将accept()设置为Deferred模式。<br><code>accept_filter=filter</code>设置监听端口对请求的过滤，被过滤的内容不能被接收和处理。<br>bind,标识符        使用独立的bind()处理次address:port 一般情况下，对于端口相同二IP地址不同的多个连接，nginx服务器将只是用一个监听命令，并使用bind()处理端口相同的所有连接。<br>ssl ,标识符 设置会话连接使用SSL模式进行，茨表示服和nginx服务器提供的https服务有关，</p><pre><code>listen *:80|*:8000;listen 192.168.1.1:8000;listen 8000;listen 192.168.1.10 default_server backlog=1024;</code></pre><p>设置192.168.1.10的链接请求默认由此虚拟主机处理<br>        并且允许最多1024网络连接同事处于挂起状态。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx内置变量</title>
      <link href="/posts/9883.html"/>
      <url>/posts/9883.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>$arg_PARAMETER</code>客户端GET请求中变量名PARAMETER参数的值。</p><p><code>$args</code>这个变量等于GET请求中的参数。例如，<code>foo=123&amp;bar=blahblah</code>;这个变量只可以被修改</p><p><code>$binary_remote_addr</code> 远程地址二进制表示。</p><p><code>$body_bytes_sent</code> 已发送页面的字节数。</p><p><code>$content_length</code> HTTP请求头中的Content-length字段。</p><p><code>$content_type</code> 请求信息中的Content-Type字段。</p><p><code>$cookie_COOKIE</code> 客户端请求信息cookie COOKIE的值。</p><p><code>$document_root</code> 当前请求在根路径中指定的值。</p><p><code>$document_uri</code> 与$uri相同。</p><p><code>$host</code> 请求中的主机头(Host)字段，如果请求没有host行，则等于设置的服务器名。</p><p><code>$hostname</code> 机器名使用 gethostname系统调用的值</p><p><code>$http_HEADER</code> HTTP请求头中的内容，HEADER为HTTP请求中的内容转为小写，-变为_(破折号变为下划线)，例如：<code>$http_user_agent</code>(Uaer-Agent的值), $http_referer…;</p><p><code>$sent_http_HEADER</code> HTTP响应头中的内容，HEADER为HTTP响应中的内容转为小写，-变为_(破折号变为下划线)，例如： <code>$sent_http_cache_control</code>,<br><code>$sent_http_content_type</code><br><code>$sent_http_content_connection</code><br><code>$sent_http_content_length</code><br><code>$sent_http_keep_alive</code><br><code>$sent_http_last_modified</code><br><code>$sent_http_location</code><br><code>$sent_http_transfer_encoding</code></p><p><code>$is_args</code> 如果$args设置，值为”?”，否则为””空。</p><p><code>$limit_rate</code> 这个变量可以限制连接速率。</p><p><code>$nginx_version</code> 当前运行的nginx版本号。</p><p><code>$query_string</code> 与$args相同。</p><p><code>$remote_addr</code> 客户端的IP地址。</p><p><code>$remote_port</code> 客户端的端口。</p><p><code>$remote_user</code> 已经经过Auth Basic Module验证的用户名。</p><p><code>$request_filename</code> 当前连接请求的文件路径，由root或alias指令与URI请求生成。</p><p><code>$request_body</code> 这个变量（0.7.58+）包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义。</p><p><code>$request_body_file</code> 客户端请求主体信息的临时文件名。</p><p><code>$request_completion</code> 如果请求成功，设为”OK”；如果请求未完成或者不是一系列请求中最后一部分则设为空。</p><p><code>$request_method</code> 这个变量是客户端请求的动作，通常为GET或POST。</p><p>包括0.8.20及之前的版本中，这个变量总为main request中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作。</p><p><code>$request_uri</code> 这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI。</p><p><code>$scheme</code> 所用的协议，比如http或者是https，比如rewrite ^(.+)$ $scheme://example.com$1 redirect;</p><p><code>$server_addr</code> 服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数。</p><p><code>$server_name</code> 服务器名称。</p><p><code>$server_port</code> 请求到达服务器的端口号。</p><p><code>$server_protocol</code> 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</p><p><code>$uri</code>  请求中的当前URI(不带请求参数，参数位于$args)，不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改。不包括协议和主机名，例如/foo/bar.html</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx信号</title>
      <link href="/posts/3793.html"/>
      <url>/posts/3793.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编译安装nginx 需要安装以下包</p><pre class=" language-python"><code class="language-python">yum install gcc gcc<span class="token operator">-</span>c<span class="token operator">+</span><span class="token operator">+</span> automake autoconf pcre pcre<span class="token operator">-</span>devel zlib zlib<span class="token operator">-</span>devel openssl openssl<span class="token operator">-</span>devl<span class="token punctuation">.</span><span class="token operator">/</span>configure <span class="token operator">-</span><span class="token operator">-</span>perfix<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginxmake <span class="token operator">&amp;</span><span class="token operator">&amp;</span> make install</code></pre><p>nginx 编译安装 安装目录主要包括了conf html logs sbin等四个目录</p><p>其中 conf目录中存放了nginx的所有配置文件。<br>其中nginx.conf 文件是nginx服务器的主要配置文件。<br>其他配置文件是用来配置nginx的相关功能，<br>比如配置fastcgi使用的fastcgi.conf和fastcgi两个文件。<br>html目录中存放了nginx配武器运行过程中调用的一些html网页文件。</p><p>nginx启停控制     SIGNAL    信号</p><p>TERM或INT  快速停止nginx服务<br>QUIT        平滑停止nginx服务<br>HUP            使用心得配置文件启动进程，之后平缓停止原有进程，也就是所谓的平滑重启<br>USR1        重新打开日志文件，常用于日志切割<br>USR2        使用新版本nginx文件启动服务，之后平缓停止原有nginx进程，也就是所谓的平滑升级<br>WINCH        平缓停止worker process 用于nginx服务器平滑升级</p><p>kill SIGNAL        pid<br>kill SIGNAL        filepath<br>filepath为pid配置文件路径</p><p>nginx服务的启动<br>在linux平台下，启动nginx服务器直接运行安装目录下sbin目录中的二进制文件即<br>可。</p><pre class=" language-shell"><code class="language-shell">./sbin/nginx -hnginx version: nginx/1.16.1Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]Options:  -?,-h         : this help                ##显示帮助信息  -v            : show version and exit    ##打印版本号并退出  -V            : show version and configure options then exit  ##打印版本号和配置并退出  -t            : test configuration and exit         ## 测试配置正确性并退出  -T            : test configuration, dump it and exit        ##测试配置时只显示报错  -q            : suppress non-error messages during configuration testing        ##向主进程发送信号  -s signal     : send signal to a master process: stop, quit, reopen, reload    、######测试配置时只显示报错  -p prefix     : set prefix path (default: /home/nginx-server/)    ##指定nginx服务器路径前缀  -c filename   : set configuration file (default: conf/nginx.conf)    #指定nginx配置文件路径  -g directives : set global directives out of configuration file    #指定nginx附加配置文件路径</code></pre><p><code>./sbin/nginx -g HUP    [-c newconffile]</code></p><p><code>kill HUP 'nginx/logs/nginx.pid’  ##新的pid文件</code></p><p>nginx服务器升级<br>为了实现nginx服务器的平滑升级，新的服务器安装滤镜应该和旧的保持一致。因此建议用户在安装新服务器之前备份旧的服务器。则可以先使用一下命令将旧服务器的安装路径跟改为新服务器的安装路径。<br><code>./nginx -p newinstallpath</code><br>做好工作之后，使用一下命令实现nginx服务的平滑升级<br><code>./sbin/nginx -g USR2</code><br>其中 USR2信号用于发送平滑升级信号 或者使用<br><code>kill USR2 '/nginx/logs/nginx.pid'</code><br>通过ps -rf |grep nginx 查看新的nginx服务启动正常 在使用<br><code>./sbin/nginx -g WINCH</code><br>其中 WINCH信用用于发送平滑停止旧服务信号 或者 使用<br>kill WINCH  ‘nginx/logs/nginx.pid’<br>这样就在不停止提供web服务的前提下完成了nginx服务器的平滑升级。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讨你胡子</title>
      <link href="/posts/16735.html"/>
      <url>/posts/16735.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>4444444444444444444</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql 基础语句</title>
      <link href="/posts/32303.html"/>
      <url>/posts/32303.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>话不多说</p><p>mysql -uroot -p</p><p>show databases; //查看数据库</p><p>show tables; // 查看表</p><p>create database HA; //创建数据库</p><p>ceate table xixi(id int primary key auto__increment nut null,name varchar(20),age varcahr(20),sex enum(‘m’,’f’) default m,salary flost(5,2)); //创建表</p><p>insert into xixi values(1,’hehe’,’20’,m,’4000.00’),(2,’haha’,’22’,m,’6000.00’),(3,’yezhu’,’38’,m,’15000.00’);向表中插入数据</p><p>insert into xixi （name,age,sex….）values(1,’hehe’,’20’,m,’4000.00’),(2,’haha’,’22’,m,’6000.00’),(3,’yezhu’,’38’,m,’15000.00’);向表指定中插入数据</p><p>desc xixi;查看表中结构</p><p>explain xixi; 同上</p><p>show fields from mysql.user;</p><p>show create table xixi\G;</p><p>select now();查看当前的时间</p><p>select database();</p><p>select status;</p><p>select user();</p><p>select version();</p><p>update students set id=2;  所有的都变为2</p><p>update students set sex=’M’ where id=2；</p><p>alter table xixi add head varchar(20);   ///插入在最后面</p><p>alter table xixi add head varchar(20) after age; //插入在age后面</p><p>alter table xixi add head varchar(20) first;  //插入在最前面</p><p>alter table xixi drop  sex; 删除sex字段</p><p>alter table xixi add modify sex tianyun; //修改sex字段类型</p><p>alter table xixi change sex to tianyun varcahr(20);修改sex字段的名字和类型</p><p>alter table 表名 rename 新表名;</p><p>drop database HA if exists;</p><p>create database HA if not exists;</p><p>create table huhu select * from xixi; //复制xixi表的结构</p><p>create user ‘xixi’@’localhost’ indetified with mysql_native_password by ‘密码’;  //创建本地用户</p><p>create user ‘xixi’@’%’ indetified with mysql_native_password by ‘密码’;  //创建远程用户</p><p>select user,host from mysql.user; //可在user表中查看结构</p><p>update mysql.user set host=’%’ name=’xixi’; 更改本地用户为远程用户</p><p>update mysql.user set host=’192.168.0.%’ name=’xixi’; 更改用户为内网网段访问</p><p>alter user ‘root’@’localhost’ identified with mysql_native_password by ‘新密码’;更改用户的密码</p><p>alter user ‘root’@’%’ identified with mysql_native_password by ‘新密码’;</p><p>//create database xixi;use xixi;</p><p>删除表</p><p>delete from mysql.user;</p><p>delete from students where id=3;</p><p>delete from students where age is null;</p><p>去重</p><p>select distinst name,age from xixi;</p><p>select  distinct id,name,age from xixi where id=3;</p><p>select * from user where age &gt;20 and salary&gt;5000;</p><p>or和and 同时存在时，先算and的两边值,逻辑与先执行</p><p>select id,name,age from xixi where id&gt;3 and age&gt;25;</p><p>别名</p><p>select name,salary,salary*14 from haha;创建别名</p><p>select name,salary,salary*14 AS gongzi from haha;别名</p><p>select CONCAT(name,’annual ‘salary:’,salary*14) AS annual_salary from example;</p><p>where salary BETWEEN 5000 AND 15000;　　//BETWEEN and 多少到多少</p><p>select name,salary from employee5 where comment is null;空</p><p>select name,salary from employee5 where comment is not null;非空</p><p>select name,salary from employee5 where salary=4000 or salary=5000 or salary=20000;</p><p>查找工资是4000或者五千或者两万的</p><p>IN关键字</p><p>select name,sakary example where salary  in (4000,5000,20000); 查找工资是4000或者五千或者两万的</p><p>select name,sakary example where salary  not in (4000,5000,20000);查找工资不是是4000或者五千或者两万的</p><p>关键字like模糊查找</p><p>select * from example where name like ‘al___’; 一个下划线代表任意一个字符</p><p>select * from example where name like ‘al%’; %代表任意多个字符</p><p>ASC升序  DESC降序</p><p>select name,salary example where order by salary DESC,comment ASC;</p><p>grant select,create,insert,update on xixi.* to ‘xixi’@’10.0.0.%’ identified by ‘123’;</p><p>grant * on <em>.</em> to ‘xixi’@’%’ identified by ‘密码’；</p><p>revoke：回收权限</p><p>REVOKE INSERT ON <em>.</em> FROM clsn@localhost;</p><p>revoke drop,delete on <em>.</em> from sys@localhost;</p><p>select * from example order by name, salary ASC limit 2,2;从第二个取值</p><p>select * from example order by name, salary ASC limit 2;取值</p><p>mysql&gt; select max(sex) from server where age=10;</p><p>+———-+</p><p>| max(sex) |</p><p>+———-+</p><p>| 7        |</p><p>+———-+</p><p>1 row in set (0.00 sec)</p><p>mysql&gt; select count(*) from server where age=10;</p><p>+———-+</p><p>| count(*) |</p><p>+———-+</p><p>|        3 |</p><p>+———-+</p><p>1 row in set (0.00 sec)</p><p>mysql&gt; select max(sex) from server where age=10;</p><p>+———-+</p><p>| max(sex) |</p><p>+———-+</p><p>| 7        |</p><p>+———-+</p><p>1 row in set (0.00 sec)</p><p>mysql&gt; select min(sex) from server where age=10;</p><p>+———-+</p><p>| min(sex) |</p><p>+———-+</p><p>| 6        |</p><p>+———-+</p><p>1 row in set (0.00 sec)</p><p>mysql&gt; select avg(sex) from server where age=10;</p><p>+——————-+</p><p>| avg(sex)          |</p><p>+——————-+</p><p>| 6.333333333333333 |</p><p>+——————-+</p><p>1 row in set (0.00 sec)</p><p>mysql&gt; select sum(sex) from server where age=10;</p><p>+———-+</p><p>| sum(sex) |</p><p>+———-+</p><p>|       19 |</p><p>+———-+</p><p>mysql&gt; select sex,GROUP_CONCAT(rnname) from server group by sex;</p><p>+——+———————-+</p><p>| sex  | GROUP_CONCAT(rnname) |</p><p>+——+———————-+</p><p>| 6    | lanzi,gouzi          |</p><p>| 7    | daqiang              |</p><p>+——+———————-+</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes dashboard 2.0</title>
      <link href="/posts/28677.html"/>
      <url>/posts/28677.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>kubernetes dashboard 2.0<br>本文介绍 kubernetes dashboard 不同于同类博客部署的1.10版本本文部署2.0.0版本</p><h1 id="kubenetes-v17-3"><a href="#kubenetes-v17-3" class="headerlink" title="kubenetes v17.3"></a>kubenetes v17.3</h1><h2 id="1-由于镜像地址需要上网-国内好像无法下载image"><a href="#1-由于镜像地址需要上网-国内好像无法下载image" class="headerlink" title="1.由于镜像地址需要上网 国内好像无法下载image"></a>1.由于镜像地址需要上网 国内好像无法下载image</h2><p>2.这是dashboard 2.0版本地址</p><pre class=" language-yml"><code class="language-yml">wget  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yamlkubectl apply -f recommended.yaml</code></pre><p><img src="/images/pasted-29.png" alt="upload successful"><br>对于image  可查看node节点地址 在node节点地址上 docker pull  image</p><p>在yml文件里 pull对应的版本地址 国内缓慢   可走docker代理或pull阿里云的镜像后修改tag标签</p><p>部署完之后可以查看默认的权限 默认权限几乎什么都不能干，根据官方说明 需要授权rbac权限</p><p>官方地址 </p><p><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md</a></p><h2 id="3-授权"><a href="#3-授权" class="headerlink" title="3.授权"></a>3.授权</h2><p>创建样本用户<br>在本指南中，我们将找到如何使用Kubernetes的服务帐户机制创建新用户，授予该用户admin权限以及使用与该用户绑定的承载令牌登录到Dashboard的方法。</p><p>重要信息：在继续操作之前，请确保您知道自己在做什么。向仪表板的服务帐户授予管理员特权可能会带来安全风险。</p><p>对于每个以下片断ServiceAccount和ClusterRoleBinding，你应该将它们复制到像新的清单文件dashboard-adminuser.yaml，并使用kubectl apply -f dashboard-adminuser.yaml创建它们。</p><h2 id="4-创建服务账号"><a href="#4-创建服务账号" class="headerlink" title="4.创建服务账号"></a>4.创建服务账号</h2><pre class=" language-yml"><code class="language-yml">apiVersion: v1kind: ServiceAccountmetadata:  name: admin-user  namespace: kubernetes-dashboard</code></pre><p>创建ClusterRoleBinding<br>在大多数情况下，使用kops或kubeadm任何其他流行的工具配置集群后，集群中ClusterRole cluster-admin已经存在该集群。我们可以使用它并仅为ClusterRoleBinding我们创建ServiceAccount。</p><p>注意： Kubernetes版本之间apiVersion的ClusterRoleBinding资源可能有所不同。此前Kubernetes v1.8的apiVersion是rbac.authorization.k8s.io/v1beta1。</p><pre class=" language-yml[']"><code class="language-yml[']">apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  name: admin-userroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:- kind: ServiceAccount  name: admin-user  namespace: kubernetes-dashboard</code></pre><p>此时可以查看密令<br>kubectl -n kubernetes-dashboard描述秘密$（ kubectl -n kubernetes-dashboard获取秘密| grep管理员用户| awk ‘ {print $ 1} ‘）</p><pre class=" language-yml"><code class="language-yml">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '{print $1}')kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | sls admin-user | ForEach-Object { $_ -Split '\s+' } | Select -First 1)</code></pre><p><img src="/images/pasted-30.png" alt="upload successful"></p><pre class=" language-yml"><code class="language-yml">cat recommended.yaml # Copyright 2017 The Kubernetes Authors.## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at##     http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.apiVersion: v1kind: Namespacemetadata:  name: kubernetes-dashboard---apiVersion: v1kind: ServiceAccountmetadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboard---kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardspec:  type: NodePort  ports:    - port: 443      targetPort: 8443  selector:    k8s-app: kubernetes-dashboard---apiVersion: v1kind: Secretmetadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard-certs  namespace: kubernetes-dashboardtype: Opaque---apiVersion: v1kind: Secretmetadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard-csrf  namespace: kubernetes-dashboardtype: Opaquedata:  csrf: ""---apiVersion: v1kind: Secretmetadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard-key-holder  namespace: kubernetes-dashboardtype: Opaque---kind: ConfigMapapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard-settings  namespace: kubernetes-dashboard---kind: RoleapiVersion: rbac.authorization.k8s.io/v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardrules:  # Allow Dashboard to get, update and delete Dashboard exclusive secrets.  - apiGroups: [""]    resources: ["secrets"]    resourceNames: ["kubernetes-dashboard-key-holder", "kubernetes-dashboard-certs", "kubernetes-dashboard-csrf"]    verbs: ["get", "update", "delete"]    # Allow Dashboard to get and update 'kubernetes-dashboard-settings' config map.  - apiGroups: [""]    resources: ["configmaps"]    resourceNames: ["kubernetes-dashboard-settings"]    verbs: ["get", "update"]    # Allow Dashboard to get metrics.  - apiGroups: [""]    resources: ["services"]    resourceNames: ["heapster", "dashboard-metrics-scraper"]    verbs: ["proxy"]  - apiGroups: [""]    resources: ["services/proxy"]    resourceNames: ["heapster", "http:heapster:", "https:heapster:", "dashboard-metrics-scraper", "http:dashboard-metrics-scraper"]    verbs: ["get"]---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboardrules:  # Allow Metrics Scraper to get metrics from the Metrics server  - apiGroups: ["metrics.k8s.io"]    resources: ["pods", "nodes"]    verbs: ["get", "list", "watch"]---apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardroleRef:  apiGroup: rbac.authorization.k8s.io  kind: Role  name: kubernetes-dashboardsubjects:  - kind: ServiceAccount    name: kubernetes-dashboard    namespace: kubernetes-dashboard---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  name: kubernetes-dashboardroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: kubernetes-dashboardsubjects:  - kind: ServiceAccount    name: kubernetes-dashboard    namespace: kubernetes-dashboard---kind: DeploymentapiVersion: apps/v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardspec:  replicas: 1  revisionHistoryLimit: 10  selector:    matchLabels:      k8s-app: kubernetes-dashboard  template:    metadata:      labels:        k8s-app: kubernetes-dashboard    spec:      containers:        - name: kubernetes-dashboard          image: kubernetesui/dashboard:v2.0.0-rc6          imagePullPolicy: Always          ports:            - containerPort: 8443              protocol: TCP          args:            - --auto-generate-certificates            - --namespace=kubernetes-dashboard            # Uncomment the following line to manually specify Kubernetes API server Host            # If not specified, Dashboard will attempt to auto discover the API server and connect            # to it. Uncomment only if the default does not work.            # - --apiserver-host=http://my-address:port          volumeMounts:            - name: kubernetes-dashboard-certs              mountPath: /certs              # Create on-disk volume to store exec logs            - mountPath: /tmp              name: tmp-volume          livenessProbe:            httpGet:              scheme: HTTPS              path: /              port: 8443            initialDelaySeconds: 30            timeoutSeconds: 30          securityContext:            allowPrivilegeEscalation: false            readOnlyRootFilesystem: true            runAsUser: 1001            runAsGroup: 2001      volumes:        - name: kubernetes-dashboard-certs          secret:            secretName: kubernetes-dashboard-certs        - name: tmp-volume          emptyDir: {}      serviceAccountName: kubernetes-dashboard      nodeSelector:        "beta.kubernetes.io/os": linux      # Comment the following tolerations if Dashboard must not be deployed on master      tolerations:        - key: node-role.kubernetes.io/master          effect: NoSchedule---kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: dashboard-metrics-scraper  name: dashboard-metrics-scraper  namespace: kubernetes-dashboardspec:  ports:    - port: 8000      targetPort: 8000  selector:    k8s-app: dashboard-metrics-scraper---kind: DeploymentapiVersion: apps/v1metadata:  labels:    k8s-app: dashboard-metrics-scraper  name: dashboard-metrics-scraper  namespace: kubernetes-dashboardspec:  replicas: 1  revisionHistoryLimit: 10  selector:    matchLabels:      k8s-app: dashboard-metrics-scraper  template:    metadata:      labels:        k8s-app: dashboard-metrics-scraper      annotations:        seccomp.security.alpha.kubernetes.io/pod: 'runtime/default'    spec:      containers:        - name: dashboard-metrics-scraper          image: kubernetesui/metrics-scraper:v1.0.3          ports:            - containerPort: 8000              protocol: TCP          livenessProbe:            httpGet:              scheme: HTTP              path: /              port: 8000            initialDelaySeconds: 30            timeoutSeconds: 30          volumeMounts:          - mountPath: /tmp            name: tmp-volume          securityContext:            allowPrivilegeEscalation: false            readOnlyRootFilesystem: true            runAsUser: 1001            runAsGroup: 2001      serviceAccountName: kubernetes-dashboard      nodeSelector:        "beta.kubernetes.io/os": linux      # Comment the following tolerations if Dashboard must not be deployed on master      tolerations:        - key: node-role.kubernetes.io/master          effect: NoSchedule      volumes:        - name: tmp-volume          emptyDir: {}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ingress nginx and tomcat</title>
      <link href="/posts/1574.html"/>
      <url>/posts/1574.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>###首先创建Service and Deployment</p><p>service和pod仅可在集群内部网络中通过IP地址访问。所有到达边界路由器的流量或被丢弃或被转发到其他地方。从概念上讲，可能像下面这样：</p><p>service模式  分为cluster IP and nodePort </p><p>nodePort模式映射端口 可映射为固定端口，也可为随机端口。</p><p><img src="/images/pasted-17.png" alt="upload successful"><br>cluster IP模式 定义cluster IP 通过访问cluster IP达到访问效果。</p><p>nodeport模式   将本地80端口映射为32080端口 通过外部访问每个node节点 32080端口即可达到访问效果 默认负载均衡。。。</p><p><img src="/images/pasted-18.png" alt="upload successful"><br>Internet   =====》 services</p><p>Ingress是授权入站连接到达集群服务的规则集合。</p><p>intetnet =====》 ingress =====》services  ======》 pods</p><p>　　你可以给Ingress配置提供外部可访问的URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过POST Ingress资源到API server的方式来请求ingress。 Ingress controller负责实现Ingress，通常使用负载平衡器，它还可以配置边界路由和其他前端，这有助于以HA方式处理流量。</p><p>[root@master1 ing]# cat demo.yaml                                  ###这是service and deployment的配置清单</p><pre class=" language-yml"><code class="language-yml">apiVersion: v1                                  #版本kind: Service                                    #类型metadata:                                          #元数据     name: myapp  　　　　　　　　#元数据名字     namespace: default　　　　　　#名称空间spec:　　　　　　　　　　　　　　#规格    selector:　　　　　　　　　　　　#标签选择        app: myapp　　　　　　　　　　#标签        release: stableports:  　　　　　　　　　　　　#端口  object 对象- name: myapp　　　　　　　　#端口名字   port: 80　　　　　　　　　　#service端口targetPort: 80　　　　　　　　#pod端口---　　　　　　　　　　　　　　###分割   apiVersion: apps/v1　　　　　　#版本kind: Deployment　　　　　　　# 类型metadata:　　　　　　　　　　#元数据     name: myapp　　　　　　　　#deployment的名字     namespace: default　　　　　　##所属的名称空间spec:　　　　　　　　　　　　　　#规格    selector:　　　　　　　　　　　　###标签选择器        matchLabels:　　　　　　　　　　###匹配标签                app: myapp                             ###标签             release: stable    replicas: 3　　　　　　　　　　###副本数    template:　　　　　　　　　　###资源 又包括 metadata and spec       metadata:　　　　　　　　            labels:　　　　app: myapp　　　　release: stable       spec:　　　 containers:               ###这里跟pod创建模式一样 　　　  - name: myapp      ##容器名　　　　 image: nginx　　　　###镜像　　　  ports:　　　　　　###端口　　　   - name: http　　　　　　###定义端口名字　　services　     containerPort: 80　　　　###pod端口</code></pre><p>kubectl apply -f 加上配置清单name</p><p><img src="/images/pasted-19.png" alt="upload successful"><br>services</p><p><img src="/images/pasted-20.png" alt="upload successful"><br> #####创建nodePort</p><p> #####创建nodePort</p><pre class=" language-yml"><code class="language-yml">apiVersion: v1kind: Servicemetadata:name: ingress-nginxnamespace: ingress-nginx　　labels:          　　　　　　　　　　　　###至于labels  可写可不写　　　　app.kubernetes.io/name: ingress-nginx　　　　app.kubernetes.io/part-of: ingress-nginxspec:    type: NodePort    ports:     - name: http 　　port: 80　　targetPort: 80　　protocol: TCP　　nodePort: 32080 #http　　- name: https　　port: 443　　targetPort: 443　　protocol: TCP　　nodePort: 32443 #https    selector:　　app.kubernetes.io/name: ingress-nginx　　app.kubernetes.io/part-of: ingress-nginx</code></pre><p><img src="/images/pasted-21.png" alt="upload successful"></p><p> ##########ingress 配置</p><pre class=" language-yml"><code class="language-yml">apiVersion: extensions/v1beta1kind: Ingressmetadata:name: ingress-myappnamespace: defaultannotations:kubernetes.io/ingress.class: "nginx"spec:rules:- host: httpd.hequan.comhttp:paths:- path:backend:serviceName: myappservicePort: 80</code></pre><p><img src="/images/pasted-22.png" alt="upload successful"></p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p><img src="/images/pasted-24.png" alt="upload successful"></p><p>##########tomcat配置文件</p><p>[root@master1 ing]# cat tomncat.yaml </p><pre class=" language-yml"><code class="language-yml">apiVersion: v1kind: Servicemetadata:   name: tomcat-svc  namespace: defaultspec:  selector:      app: tomcat      release: canary  ports:  - name: http     targetPort: 8080     port: 8080  -  name: ajp      targetPort: 8009     port: 8009---apiVersion: apps/v1kind: Deploymentmetadata:     name: tomcat-deploy     namespace: defaultspec:    replicas: 3    selector:        matchLabels:             app: tomcat             release: canary    template:       metadata:             labels:               app: tomcat               release: canary        spec:            containers:            - name: tomcat              image: tomcat:8.5.32-jre8-alpine              ports:              - name: http                containerPort: 8080              - name: ajp                containerPort: 8009</code></pre><p> ###############</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p><img src="/images/pasted-26.png" alt="upload successful"><br>###########如若需要namespace</p><p>kubectl create ns ingress-tomcat</p><p>将各配置文件metadata模块 namespace换成同一个即可</p><p>######tls 443端口</p><pre class=" language-yml"><code class="language-yml">openssl genrsa -out tls.key 2048openssl req -new -x509 -key tls.key -out tls.crt -subj /C=CN/ST=Shanghai/L=Shanghai/O=Devops/CN=tomcat.magedu.comkubectl create secret tls tomcat-ingress-secret --cert=tls.crt --key=tls.key  kubectl get secretkubectl describe secret tomcat-ingress-secret kubectl explain ingress.spec.tls</code></pre><p><img src="/images/pasted-27.png" alt="upload successful"><br>kubectl apply -f ing-tomcat.yaml</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> docker </tag>
            
            <tag> ingress </tag>
            
            <tag> nginx </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix监控mysql8.0</title>
      <link href="/posts/43514.html"/>
      <url>/posts/43514.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一次的文章写得简直惨不忍睹。</p><p>首先我用官方自带模板</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><p> 然后就会出现</p><p><img src="/images/pasted-6.png" alt="upload successful"><br> 我是二进制部署</p><p><img src="/images/pasted-7.png" alt="upload successful"><br>就在源码包里有默认的mysql模板配置文件</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p> cp 至  /usr/local/zabbix/etc/zabbix-agent.d/</p><p> 然后在mysql的配置文件下配置有权限的用户即可</p><p><img src="/images/pasted-9.png" alt="upload successful"></p><p> 随后重启mysql and agentd</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><ol start="2"><li><p>自定义脚本</p><pre class=" language-yml"><code class="language-yml">[root@zabbix scripts]# cat mysql.sh #!/bin/bash#用户名MYSQL_USER='root'#密码MYSQL_PASSWORD='shanyao@2020'#主机地址/IPMYSQL_HOST='127.0.0.1'#端口MYSQL_PORT='3306'#数据连接MYSQL_CONN="/usr/bin/mysqladmin"#参数是否正确if [ $# -ne "1" ];thenecho "arg error!"fi#获取数据case $1 inUptime)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null status|awk  '{print $2}'`    echo $result    ;;Threads)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null status|awk  '{print $4}'`    echo $result    ;;Questions)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null status|awk  '{print $6}'`    echo $result    ;;Queries_avg)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null status|awk  '{print $NF}'`    echo $result    ;;Com_update)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Com_update"|awk -F'|' '{print $3}'`    echo $result    ;;Slow_queries)    result=`${MYSQL_CONN}  -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null status|awk '{print $9}'`    echo $result    ;;Com_select)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Com_select"|awk -F'|' '{print $3}'`    echo $result    ;;Com_rollback)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Com_rollback"|awk -F'|' '{print $3}'`    echo $result    ;;Com_insert)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Com_insert"|awk -F'|' '{print $3}'`    echo $result    ;;Com_delete)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Com_delete"|awk -F'|' '{print $3}'`    echo $result    ;;Com_commit)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Com_commit"|awk -F'|' '{print $3}'`    echo $result    ;;Bytes_sent)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Bytes_sent" |awk -F'|' '{print $3}'`    echo $result    ;;Bytes_received)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Bytes_received" |awk -F'|' '{print $3}'`    echo $result    ;;Com_begin)    result=`${MYSQL_CONN} -u${MYSQL_USER} -p${MYSQL_PASSWORD} 2>/dev/null extended-status |grep -w "Com_begin"|awk -F'|' '{print $3}'`    echo $result    ;;    *)    echo "Usage:$0(Uptime|Threads|Questions|Questions_avg|Com_update|Slow_queries|Com_select|Com_rollback|Questions|Com_insert|Com_delete|Com_commit|Bytes_sent|Bytes_received|Com_begin)"    ;;esac</code></pre></li></ol><pre><code> ```yml[root@zabbix scripts]# cd /usr/local/zabbix/etc/zabbix_agentd.conf.d/[root@zabbix zabbix_agentd.conf.d]# lsmysql_status.conf  userparameter_mysql.conf[root@zabbix zabbix_agentd.conf.d]# cat mysql_status.conf UserParameter=mysql.status[*],/server/scripts/mysql.sh $1#UserParameter=mysql.ping,HOME=/usr/local/zabbix/etc /usr/bin/mysqladmin -uroot -pshanyao@2020  ping|grep alive|wc -l#UserParameter=mysql.version,mysql -V |awk '{print $5}'|sed 's/,//'[root@zabbix zabbix_agentd.conf.d]# ```注释的条目是我在配置系统自带模板的时候，名称冲突重启zabbix-agentd，在item监控项里添加![upload successful](/images/pasted-11.png)后置创建图形 选中自建item项![upload successful](/images/pasted-12.png)![upload successful](/images/pasted-13.png)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 监控 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> linux </tag>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ceph集群部署</title>
      <link href="/posts/2609.html"/>
      <url>/posts/2609.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>master node1 node2 client<br>192.168.1.31    master<br>192.168.1.29    node1<br>192.168.1.156 node2<br>192.168.1.98    client</p><p>yum install wget vim epel-release<br>配置阿里云的centos7镜像和ceph.repo库<br>[root@master ceph]# cat /etc/yum.repos.d/ceph.repo<br>[Ceph]<br>name=Ceph packages for $basearch<br>baseurl=<a href="https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-jewel/el7/$basearch" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-jewel/el7/$basearch</a><br>enabled=1<br>gpgcheck=1<br>type=rpm-md<br>gpgkey=<a href="https://mirrors.tuna.tsinghua.edu.cn/ceph/keys/release.asc" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ceph/keys/release.asc</a><br>priority=1</p><p>[Ceph-noarch]<br>name=Ceph noarch packages<br>baseurl=<a href="https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-jewel/el7/noarch" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-jewel/el7/noarch</a><br>enabled=1<br>gpgcheck=1<br>type=rpm-md<br>gpgkey=<a href="https://mirrors.tuna.tsinghua.edu.cn/ceph/keys/release.asc" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ceph/keys/release.asc</a><br>priority=1</p><p>[ceph-source]<br>name=Ceph source packages<br>baseurl=<a href="https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-jewel/el7/SRPMS" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-jewel/el7/SRPMS</a><br>enabled=1<br>gpgcheck=1<br>type=rpm-md<br>gpgkey=<a href="https://mirrors.tuna.tsinghua.edu.cn/ceph/keys/release.asc" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ceph/keys/release.asc</a><br>priority=1</p><p>#关闭所有节点防火墙和SELINUX</p><p>yum install yum-utils ceph ceph-deploy　　#安装ceph主程序和管理工具</p><p>master节点：将ssh公钥导入其他节点方便调用时输入密码</p><p>ceph-deploy new node1 node2 初始化节点</p><p>cat /etc/ceph/ceph.conf　　#插入</p><p>osd pool default size = 2</p><p>ceph-deploy install node1 node2 #安装ceph</p><p>ceph-deploy mon create-initial 　　##初始化mon节点</p><hr><p>node1:fdisk -l<br>fdisk /dev/sdb<br>mkfs.xfs /dev/sdb1<br>mkdir /dev/local/osd1<br>vim /etc/fstab<br>/dev/sdb1 /dev/local/osd1 xfs defaults 0 0<br>chown ceph:ceph /dev/local/osd1<br>node2:fdisk -l<br>fdisk /dev/sdb<br>mkfs.xfs /dev/sdb1<br>mkdir /dev/local/osd1<br>vim /etc/fstab<br>/dev/sdb1 /dev/local/osd1 xfs defaults 0 0<br>chown ceph:ceph /dev/local/osd1</p><p>ceph-deploy osd prepare node1:/dev/local/osd1 node2:/dev/local/osd1<br>chmod +r /etc/ceph/ceph.client.admin.keyring<br>ceph-deploy osd activate node1:/dev/local/osd1 node2:/dev/local/osd1<br>ceph quorum_status –format json-pretty 　　##查看Ceph群集详细信息</p><p>ceph health</p><p>HEALTH_OK</p><p> #这里有一个警告 可以不用太在意</p><p>client测试</p><p>ceph-deploy install ceph-client 　　##提示输入密码</p><p>ceph-deploy admin ceph-client</p><p>chmod +r /etc/ceph/ceph.client.admin.keyring</p><p>master:　　ceph osd pool create cephfs_data 128 　　##数据存储池<br>pool ‘cephfs_data’ created<br>master:　　 ceph osd pool create cephfs_metadata 128 　　##元数据存储池<br>pool ‘cephfs_metadata’ created<br>master:　　ceph fs new cephfs cephfs_data cephfs_metadata 　　##创建文件系统<br>new fs with metadata pool 1 and data pool 2</p><p> 挂载</p><p>[root@ceph-client ~]# mkdir /mnt/ceph</p><p>[root@ceph-client ~]# grep key /etc/ceph/ceph.client.admin.keyring |awk ‘{print $3}’ &gt;&gt;/etc/ceph/admin.secret</p><p>[root@ceph-client ~]# cat /etc/ceph/admin.secret</p><p>AQCd/x9bsMqKFBAAZRNXpU5QstsPlfe1/FvPtQ==<br>mount -t ceph 192.168.1.29:6789:/ /mnt/ceph/ -v -o name=admin,secretfile=/etc/ceph/admin.secret</p><p>mount -t ceph 192.168.1.156:6789:/ /mnt/ceph1/ -v -o name=admin,secretfile=/etc/ceph/admin.secret</p><p>dd if=/dev/zero of=/mnt/ceph/1.file bs=1G count=1</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/posts/58122.html"/>
      <url>/posts/58122.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>title: typora-vue-theme主题介绍<br>date: 2018-09-07 09:25:00<br>author: 赵奇<br>img: /source/images/xxx.jpg<br>top: true<br>cover: true<br>coverImg: /images/1.jpg<br>password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<br>toc: false<br>mathjax: false<br>summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<br>categories: Markdown<br>tags:</p><ul><li>linux </li><li>nginx</li><li>运维</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql8.0</title>
      <link href="/posts/22489.html"/>
      <url>/posts/22489.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre class=" language-yml"><code class="language-yml">---本文用mysql8.0.16和8.0.17做主从复制yum install mysql-comminuty-servergrep 'password' /var/log/mysql.log  //筛选临时密码mysqladmin -p'临时密码' password‘new’log-bin=mysql-binserver-id=1systemctl restart mysqldcreate user 'repl'@'%' identified with navite_password by   '密码'；grant replication salve on *.* to 'repl'@'%';flush privileges;show master status;mysqldump -uroot -p密码 -all-databases --master-data=1 > /root/all.sqlscp -r /root/all.sql root@从IP地址:/root从：yum install mysql-community-servergrep 'password' /var/log/mysql.log  //筛选临时密码mysqladmin -p'临时密码' password‘new’vi /etc/my.confservice-id=2mysql -h 主节点 -u用户 -p密码show grants; //看授权set sql_log_bin=0 //避免还原的时候生成大量的sql语句source /root/all.sql; change master to master_host='地址，master_user='用户‘,master_password='密码',master_port='端口‘；  //这里不加log_file是因为前面masterCHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS=825start slave;show slave status\G;stop slave;---</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 主从 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
